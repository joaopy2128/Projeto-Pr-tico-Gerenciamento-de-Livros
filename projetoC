/*
===================================================================================
                PROJETO PRÁTICO — GERENCIADOR DE LIVROS
-----------------------------------------------------------------------------------
TEMA: BIBLIOTECA PESSOAL (Com todos os requisitos da atividade)
====================================================================================
*/

#include <stdio.h>    // I/O
#include <stdlib.h>   // system
#include <string.h>   // strcspn
#include <ctype.h>    // toupper
#include <locale.h>   // setlocale

/* -------------------------------------------------------------------------------
   ESTRUTURA DE DADOS
   Define o registro 'livro' com mais de 3 tipos de campos.
-------------------------------------------------------------------------------- */
typedef struct {
    char titulo[100];   // char[]
    char autor[50];     // char[]
    int isbn;           // int
    float preco;        // float
} livro;

/* Protótipos das funções (Modularização) */
void configurar_locale(void);
void limpaBuffer(void);
void lerStringSegura(char *s, int tam);
int tamanho(FILE *arq);
void cadastrar(FILE *arq);
void consultar(FILE *arq);

/* ====================================================================================
   limpaBuffer (Requisito: Padronização de Nomenclatura)
   ==================================================================================== */
void limpaBuffer(void) {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

/* ====================================================================================
   lerStringSegura (Requisito Opcional: Leitura de String Segura)
   ==================================================================================== */
void lerStringSegura(char *s, int tam) {
    // Usa fgets para leitura segura e strcspn para remover o '\n'
    fgets(s, tam, stdin);
    s[strcspn(s, "\n")] = '\0';
}

/* ====================================================================================
   tamanho (Requisito: Calcula o número de registros)
   ==================================================================================== */
int tamanho(FILE *arq) {
    long pos = ftell(arq);      // Salva a posição
    fseek(arq, 0, SEEK_END);    // Move para o final
    long fim = ftell(arq);      // Obtém o tamanho total em bytes
    fseek(arq, pos, SEEK_SET);  // Restaura a posição
    
    // Retorna o número de registros (tamanho_total / sizeof(livro))
    return (int)(fim / sizeof(livro));
}

/* ====================================================================================
   cadastrar (Requisito: Salva a struct no final do arquivo)
   ==================================================================================== */
void cadastrar(FILE *arq) {
    livro novo_livro;
    char confirma;

    printf("\n=== CADASTRAR LIVRO ===\n");
    printf("Registro número: %d\n", tamanho(arq) + 1);

    printf("Título: ");
    lerStringSegura(novo_livro.titulo, sizeof(novo_livro.titulo)); 
    
    printf("Autor: ");
    lerStringSegura(novo_livro.autor, sizeof(novo_livro.autor));
    
    printf("ISBN (número inteiro): ");
    if (scanf("%d", &novo_livro.isbn) != 1) {
        printf("Entrada inválida. ISBN deve ser um número inteiro.\n");
        limpaBuffer(); return;
    }
    
    printf("Preço (R$ 0.00): ");
    if (scanf("%f", &novo_livro.preco) != 1) {
        printf("Entrada inválida. Preço deve ser um número decimal.\n");
        limpaBuffer(); return;
    }

    limpaBuffer(); // Limpar o '\n' após o último scanf (preço)
    printf("Confirmar cadastro (s/n)? ");
    if (scanf("%c", &confirma) != 1) { 
        printf("Entrada inválida. Cancelando cadastro.\n");
        limpaBuffer(); return;
    }
    limpaBuffer(); // Limpar o '\n' após a confirmação

    if (toupper(confirma) == 'S') {
        fseek(arq, 0, SEEK_END);                       // Posiciona no fim
        fwrite(&novo_livro, sizeof(livro), 1, arq);    // Salva a struct
        fflush(arq);                                   
        printf("Livro cadastrado com sucesso!\n");
    } else {
        printf("Cadastro cancelado.\n");
    }
}

/* ====================================================================================
   consultar (Requisito: Exibe o registro pelo código/índice)
   ==================================================================================== */
void consultar(FILE *arq) {
    int indice;
    livro livro_lido;

    printf("\n=== CONSULTAR LIVRO ===\n");
    printf("Informe o ÍNDICE do livro (1 a %d): ", tamanho(arq));
    if (scanf("%d", &indice) != 1) {
        printf("Entrada inválida!\n");
        limpaBuffer();
        return;
    }
    limpaBuffer(); 

    int total = tamanho(arq);

    if (indice <= 0 || indice > total) {
        printf("Índice inválido! A biblioteca possui %d livros.\n", total);
        return;
    }

    // Calcula a posição em bytes: (índice - 1) * tamanho_do_registro
    long pos_byte = (long)(indice - 1) * sizeof(livro);

    // Move o ponteiro (fseek(SEEK_SET))
    if (fseek(arq, pos_byte, SEEK_SET) != 0) {
        printf("[ERRO] Falha ao posicionar ponteiro no arquivo.\n");
        return;
    }

    // Lê o registro (fread)
    size_t lido = fread(&livro_lido, sizeof(livro), 1, arq);

    if (lido != 1) {
        printf("[ERRO] Falha ao ler registro!\n");
        return;
    }

    printf("\n--- LIVRO (ÍNDICE %d) ---\n", indice);
    printf("Título: %s\n", livro_lido.titulo);
    printf("Autor: %s\n", livro_lido.autor);
    printf("ISBN: %d\n", livro_lido.isbn);
    printf("Preço: R$ %.2f\n", livro_lido.preco);
}

/* ====================================================================================
   configurar_locale
   ==================================================================================== */
void configurar_locale(void) {
    #if defined(_WIN32)
    system("chcp 65001 > nul");
    #endif

    const char *locais[] = {
        "pt_BR.UTF-8",
        "pt_BR.utf8",
        "Portuguese"
    };
    int i; 
    for (i = 0; i < 3; i++) {
        if (setlocale(LC_ALL, locais[i]) != NULL) {
            return;
        }
    }
}

/* ====================================================================================
   main — FUNÇÃO PRINCIPAL (Requisito: Módulo de Arquivos)
   ==================================================================================== */
int main(void) {
    configurar_locale();
    
    // Tenta abrir/criar o arquivo binário (r+b ou w+b)
    FILE *arq = fopen("biblioteca.dat", "r+b"); 
    
    if (!arq) {
        arq = fopen("biblioteca.dat", "w+b");
        if (!arq) {
            printf("Erro crítico ao abrir/criar arquivo de dados.\n");
            return 1;
        }
    }

    int op;
    do {
        printf("\n====== BIBLIOTECA PESSOAL (C PURO) ======\n");
        printf("1. Cadastrar Livro\n");
        printf("2. Consultar Livro (por Índice)\n");
        printf("3. Sair\n");
        printf("------------------------------------------\n");
        printf("Livros cadastrados: %d\n", tamanho(arq));
        printf("Opção: ");
        
        if (scanf("%d", &op) != 1) {
            printf("Digite um número válido.\n");
            limpaBuffer(); 
            continue;
        }
        limpaBuffer(); 

        switch (op) {
            case 1: cadastrar(arq); break;
            case 2: consultar(arq); break;
            case 3: printf("Fechando arquivo e salvando dados...\n"); break;
            default: printf("Opção inválida!\n");
        }
    } while (op != 3);

    fclose(arq); 
    return 0;
}